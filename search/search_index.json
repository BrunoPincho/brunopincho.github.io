{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".entry Hacking blog. A celebration of free speech, where I share fun stuff I build or find out.","title":".entry"},{"location":"#entry","text":"Hacking blog. A celebration of free speech, where I share fun stuff I build or find out.","title":".entry"},{"location":"MessageBoxInjection/","text":".Shellcode injection using MessageBox While trying to learn more about callback functions and how they can be used in native development I sort off stumbled onto a clunky code injection vector. I don't believe it's very documented so heres a blogpost. Base structures and APIs The injection technique is essentially a callback function code injection. We'll start with the structure holding everything together: typedef struct tagMSGBOXPARAMSW { UINT cbSize; HWND hwndOwner; HINSTANCE hInstance; LPCWSTR lpszText; LPCWSTR lpszCaption; DWORD dwStyle; LPCWSTR lpszIcon; DWORD_PTR dwContextHelpId; MSGBOXCALLBACK lpfnMsgBoxCallback; DWORD dwLanguageId; } MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW; So tagMSGBOXPARAMSW or MSGBOXPARAMSW, is a structure that'll contain all the necessary info to assemble and display a MessageBox dialog. What caught my eye when reading the documentation was naturally the MSGBOXCALLBACK parameter, reading the description A pointer to the callback function that processes help events for the message box. The callback function has the following form: , confirms both that it can be used for injection and its main limitation - it needs a manual trigger and will block the main thread execution, since the callback function is triggered as a response to a click in the help button. To create the MessageBox I just needed to feed the structure to the MessageBoxIndirectA function. Since the technique is kinda simple, to make it more interesting I made the MSGBOXPARAMSW structure call itself, but more on that later. In the begining we initialized everything as 0x00 and set the struct size to sizeof(MSGBOXPARAMS) which is an alias to MSGBOXPARAMSW. MSGBOXPARAMS mbp = {0}; mbp.cbSize = sizeof(MSGBOXPARAMS); mbp.hwndOwner = NULL; mbp.hInstance = GetModuleHandle(NULL); mbp.lpszText = L\"Hello world\"; mbp.lpszCaption = L\"Launchpad messagebox\"; The window handle owner can be set to null, it wont make any difference, the same for hInstance. Since lpszIcon is a pointer, more specifically, LPCWSTR , we can cast the pointer to the shellcode buffer from unsigned char* to the same type. And of course we'll need the help button. mbp.lpszIcon = (LPCWSTR)buf; mbp.dwStyle = MB_HELP; mbp.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT); Finally we set the callback to point to the address of the MSGBOXPARAMS's icon, which is itself pointing to the shellcode buffer: mbp.lpfnMsgBoxCallback = (MSGBOXCALLBACK)mbp.lpszIcon; We just need to type cast LPCWSTR as MSGBOXCALLBACK and mark the memory as executable: VirtualProtect((LPVOID)mbp.lpszIcon, 510, PAGE_EXECUTE_READ, &dwOldProtection) POC The rest is business as usual: Cool thing about this technique is how it allows to steer away from heavily monitored windows API functions.","title":".Shellcode injection using MessageBox"},{"location":"MessageBoxInjection/#shellcode-injection-using-messagebox","text":"While trying to learn more about callback functions and how they can be used in native development I sort off stumbled onto a clunky code injection vector. I don't believe it's very documented so heres a blogpost.","title":".Shellcode injection using MessageBox"},{"location":"MessageBoxInjection/#base-structures-and-apis","text":"The injection technique is essentially a callback function code injection. We'll start with the structure holding everything together: typedef struct tagMSGBOXPARAMSW { UINT cbSize; HWND hwndOwner; HINSTANCE hInstance; LPCWSTR lpszText; LPCWSTR lpszCaption; DWORD dwStyle; LPCWSTR lpszIcon; DWORD_PTR dwContextHelpId; MSGBOXCALLBACK lpfnMsgBoxCallback; DWORD dwLanguageId; } MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW; So tagMSGBOXPARAMSW or MSGBOXPARAMSW, is a structure that'll contain all the necessary info to assemble and display a MessageBox dialog. What caught my eye when reading the documentation was naturally the MSGBOXCALLBACK parameter, reading the description A pointer to the callback function that processes help events for the message box. The callback function has the following form: , confirms both that it can be used for injection and its main limitation - it needs a manual trigger and will block the main thread execution, since the callback function is triggered as a response to a click in the help button. To create the MessageBox I just needed to feed the structure to the MessageBoxIndirectA function. Since the technique is kinda simple, to make it more interesting I made the MSGBOXPARAMSW structure call itself, but more on that later. In the begining we initialized everything as 0x00 and set the struct size to sizeof(MSGBOXPARAMS) which is an alias to MSGBOXPARAMSW. MSGBOXPARAMS mbp = {0}; mbp.cbSize = sizeof(MSGBOXPARAMS); mbp.hwndOwner = NULL; mbp.hInstance = GetModuleHandle(NULL); mbp.lpszText = L\"Hello world\"; mbp.lpszCaption = L\"Launchpad messagebox\"; The window handle owner can be set to null, it wont make any difference, the same for hInstance. Since lpszIcon is a pointer, more specifically, LPCWSTR , we can cast the pointer to the shellcode buffer from unsigned char* to the same type. And of course we'll need the help button. mbp.lpszIcon = (LPCWSTR)buf; mbp.dwStyle = MB_HELP; mbp.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT); Finally we set the callback to point to the address of the MSGBOXPARAMS's icon, which is itself pointing to the shellcode buffer: mbp.lpfnMsgBoxCallback = (MSGBOXCALLBACK)mbp.lpszIcon; We just need to type cast LPCWSTR as MSGBOXCALLBACK and mark the memory as executable: VirtualProtect((LPVOID)mbp.lpszIcon, 510, PAGE_EXECUTE_READ, &dwOldProtection)","title":"Base structures and APIs"},{"location":"MessageBoxInjection/#poc","text":"The rest is business as usual: Cool thing about this technique is how it allows to steer away from heavily monitored windows API functions.","title":"POC"},{"location":"avEvasion/","text":".Antivirus Evasion Techniques This section will showcase some neat tricks and techniques to prevent anti-virus level detection of custom malware. Sleep evasion A known evasion technique to behavioral analysis by anti-viruses and malware sandboxes is to simply delay execution to force the sandbox to timeout, this way no malicious behavior indicators are detected and our malware can remain in stealth for a bit longer. Focusing more on Windows, classic sleep evasion is usually implemented using functions such as Sleep or NtDelayExecution, but their usage is so heavily associated with malware that the unobfuscated execution of these functions might easily trigger AVs or at least raise suspicion levels. Timed Mutexes When looking back at this subject, I remembered that during my uni years, in my system's programming class, we used to program with semaphores and mutexes to synchronize threads when doing parallel computing. So a mutex is basically a global variable that will indicate if it is safe to access variables or resources shared with other threads, you can use it to define a critical area in the code, in which only one thread may run at a time. A thread when entering the critical zone may lock the mutex variable, prevent other threads from entering, only unlocking it once all operations are done. Race conditions are a type of vulnerabilities that arise when developers don't correctly use synchronization tools such as these. My idea here was to simply use mutexes to block the execution of the main thread for a given time and avoid common indicators of sandbox evasion. Normally mutexes don't timeout, so you would kinda need to lock the thread with the malicious code and time another thread to eventually unlock the mutex. But with timed mutexes (C++11) we can lock a mutex, and afterwards use the try_lock_for function to attempt to lock the mutex again for a given amount of time. This will place the main thread in a state of Wait:WrAlertByThreadId , until either the mutex variable is unlocked or the function call times out. Lets compile two examples in c++ and test it against a sandbox. First the classic sleep winapi call: classicS.cpp #include \"Windows.h\" int main() { Sleep(5000000); return 0; } And the new trick, sleeping with timed mutexes: capp_noob.cpp #include <mutex> std::timed_mutex mtx; using namespace std::literals; int main() { mtx.lock(); bool result = mtx.try_lock_for(20min); mtx.unlock(); return 0; } The results show a clear difference: After submitting both samples to a sandbox analysis on a win11 x64 VM, we can see on the left the classicS.exe behaviour was considered suspicious after submitted, but on the right we have the results for capp_noob.exe, which was considered inconclusive. This doesn't mean the technique was undetectable, just that the AV didn't have enough information to accurately classify the indicators it collected as malicious. Also ignore crowdstrike falcon's 60% malicious static detection, the dam thing would consider its own family malicious if entrophy wasn't low enough. (Bypass for this in the future). Slightly lowering the entrophy will result in this outcome for capp_noob.exe: Which is now considered clean:","title":".Antivirus Evasion Techniques"},{"location":"avEvasion/#antivirus-evasion-techniques","text":"This section will showcase some neat tricks and techniques to prevent anti-virus level detection of custom malware.","title":".Antivirus Evasion Techniques"},{"location":"avEvasion/#sleep-evasion","text":"A known evasion technique to behavioral analysis by anti-viruses and malware sandboxes is to simply delay execution to force the sandbox to timeout, this way no malicious behavior indicators are detected and our malware can remain in stealth for a bit longer. Focusing more on Windows, classic sleep evasion is usually implemented using functions such as Sleep or NtDelayExecution, but their usage is so heavily associated with malware that the unobfuscated execution of these functions might easily trigger AVs or at least raise suspicion levels.","title":"Sleep evasion"},{"location":"avEvasion/#timed-mutexes","text":"When looking back at this subject, I remembered that during my uni years, in my system's programming class, we used to program with semaphores and mutexes to synchronize threads when doing parallel computing. So a mutex is basically a global variable that will indicate if it is safe to access variables or resources shared with other threads, you can use it to define a critical area in the code, in which only one thread may run at a time. A thread when entering the critical zone may lock the mutex variable, prevent other threads from entering, only unlocking it once all operations are done. Race conditions are a type of vulnerabilities that arise when developers don't correctly use synchronization tools such as these. My idea here was to simply use mutexes to block the execution of the main thread for a given time and avoid common indicators of sandbox evasion. Normally mutexes don't timeout, so you would kinda need to lock the thread with the malicious code and time another thread to eventually unlock the mutex. But with timed mutexes (C++11) we can lock a mutex, and afterwards use the try_lock_for function to attempt to lock the mutex again for a given amount of time. This will place the main thread in a state of Wait:WrAlertByThreadId , until either the mutex variable is unlocked or the function call times out. Lets compile two examples in c++ and test it against a sandbox. First the classic sleep winapi call: classicS.cpp #include \"Windows.h\" int main() { Sleep(5000000); return 0; } And the new trick, sleeping with timed mutexes: capp_noob.cpp #include <mutex> std::timed_mutex mtx; using namespace std::literals; int main() { mtx.lock(); bool result = mtx.try_lock_for(20min); mtx.unlock(); return 0; } The results show a clear difference: After submitting both samples to a sandbox analysis on a win11 x64 VM, we can see on the left the classicS.exe behaviour was considered suspicious after submitted, but on the right we have the results for capp_noob.exe, which was considered inconclusive. This doesn't mean the technique was undetectable, just that the AV didn't have enough information to accurately classify the indicators it collected as malicious. Also ignore crowdstrike falcon's 60% malicious static detection, the dam thing would consider its own family malicious if entrophy wasn't low enough. (Bypass for this in the future). Slightly lowering the entrophy will result in this outcome for capp_noob.exe: Which is now considered clean:","title":"Timed Mutexes"},{"location":"dllMemoryScanner/","text":".Companion scanner for mockingjay injection The mockingjay process injection technique, despite conceptually simple is nothing to be mocked at. The authors, acknowledging the fact that EDR systems focus more on certain win32 API calls, decided to seek an alternative which was either less dependent on these API calls or reduced their usage in some way. During their analysis of the most used injection techniques, two common operations were identified as being easily flagged as malicious: memory space allocation and changing memory protections to Read-Write-Execute (RWX), performed by NtWriteVirtualMemory and NtProtectVirtualMemory. Yup these are some of the usual surveillance targets for our friendly neighbourhood crowdstrikes, err I mean EDRs. So the solution found by Thiago et al. was to identify vulnerable DLLs with default RWX memory sections and exploit the trust these libraries hold with Windows to inject and execute shellcode undetected by modern anti-virus. The original article describing the mockingjay technique is seriously interesting, I highly recommend the reader to give it a look https://www.securityjoes.com/post/process-mockingjay-echoing-rwx-in-userland-to-achieve-code-execution. Whats this article about then? well when reading the original article myself, I noticed the authors didn't provide the source code or described their approach when looking for vulnerable DLLs. I know there's code for this out there, but i thought about writing a tool without looking too much into what other people had already done, just to learn more about the subject. Handlewalk algorithm When searching for a usable dll, the process starts by recursively crawl a target base directory, further diving into other dirs and ignoring all files without the .dll extension. After finding a library file, first thing to attempt was to load it into the program, despite not being the fastest/most stable approach, it allowed me to exclude right away libraries that couldn't be used for self-injection with the mockingjay technique. The rationale here was that if you can't load it into your process, you won't be able to exploit the memory protections anyway, at least for self-injection which is my focus here. When the algorithm manages to load a DLL, then the fun begins. The returned HMODULE handle after calling LoadLibraryA on the DLL, will be the starting point of our search for a vulnerable memory section. During research I found an interesting pattern, looking at the DLL handle we can see it pointing to the base virtual address of the library after being loaded into the processe's memory. If we look at the memory map of any loaded dll, we can confirm the next section/region is always .text, and it's always at an offset of +0x1000 from the HMODULE address. So far the logic is clear, the script loads a dll, adds 0x1000 to the library handle value to get the address of the .text section and requests information about this section, then checks the memory protections and adds the size of the section to the handle, this way we get the address of the next section and repeat the process until we find a RWX section. With the inner workings figured out, I needed to find an API function which could be used to get the size and protections of a given memory section. The obvious location to find the right tool was in memoryapi.h , looking at the documentation for VirtualQuery: SIZE_T VirtualQuery( [in, optional] LPCVOID lpAddress, [out] PMEMORY_BASIC_INFORMATION lpBuffer, [in] SIZE_T dwLength ); It takes three arguments, lpAddress is a pointer to the base address of the region we want to query, lpBuffer is a pointer to a MEMORY_BASIC_INFORMATION structure which will hold the results, and dWLength is the size, in bytes, of the MEMORY_BASIC_INFORMATION buffer. Taking a better look at this struct shows: typedef struct _MEMORY_BASIC_INFORMATION { PVOID BaseAddress; PVOID AllocationBase; DWORD AllocationProtect; WORD PartitionId; SIZE_T RegionSize; DWORD State; DWORD Protect; DWORD Type; } MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION; We can see it has the RegionSize and Protect, which will give us the size of the region in bytes and the memory protections applied to said region. Something worthy of note, which I didn't initially realised, was that the MEMORY_BASIC_INFORMATION structure returned by the VirtualQuery call, refers to a memory region, not a memory section. During development this led to one of those situations where some debugging sessions could have been avoided by more carefully reading the documentation haha. If we look at the header sections of the cygwin1.dll in PE-Bear, we can identify a certain layout: We got the .text section, and then the /4 section with a mapped virtual size of 4000 bytes. This can also be confirmed using x64dbg: But these are memory sections, what about regions? Changing the layout to display memory by regions, we can tell its slightly different: VirtualQuery would always return two different regions of 3000 and 1000 bytes after .text, instead of a single region of 4000 bytes. So my dumb self would initially get cross-eyed looking at this until I realised what the API call was returning. According to ms: \"A memory region is a single allocation that is created using a memory allocation function, such as VirtualAlloc or MapViewOfFile.\" There is also a remark on https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/ns-memoryapi-win32_memory_region_information, regarding the MEMORY_BASIC_INFORMATION structure and how it describes a \"contiguous run of pages within a single allocation that all have the same type, state and protection.\" While a section is mainly defined as: \"A section object represents a section of memory that can be shared. A process can use a section object to share parts of its memory address space (memory sections) with other processes. Section objects also provide the mechanism by which a process can map a file into its memory address space.\" What's happening here is that when a program loads a DLL, the OS first reads and maps the file's sections into the virtual memory space of the loader, and then allocates regions according to each section characteristics. This is actually observable in the last picture, the first 1000 bytes of the /4 region have ERW protections, while the last 3000 are ERWC. And that's it, to search for loadable DLLs with RWX regions the algorithm goes something like this: - Recursively search directories for .dll files. - Try to load the DLL using 'LoadLibraryA'. - If loaded, add 0x1000 to the handle's value. - VirtualQuery on the .text region. - Check memory protections and add the size of the current region to the get the next. - Repeat last instruction until the end of the DLL's virtual memory space. The code itself is nothing special, all written in c++, the directory crawling part was implemented using the FindFirstFile winapi function, with the interesting bit being the find_mockingjay function: bool find_mockingjay(HMODULE libhandle){ unsigned char* base_vaddr = (unsigned char*) &libhandle; First thing I did was to cast the HMODULE to an unsigned char* . This made arithmetics easier, allowing me to jump between memory regions by adding the size of the current region to the virtual address of the previous. Termination criteria was also something fun to write. The how is actually interesting, I noticed that the least significant byte of the upper 32 bits of the handle address value and the most significant byte of the lower 32 bits, were different for each library loaded dynamically and from the native DLLs loaded when the program started. So when eventually these specific bytes are different from the ones extracted from the original handle, you've stepped into a different memory region unrelated to the library being analysed. So for a handle with a value of 0x00007ff90e7a0000, the crawling termination bytes would be 0x0e and 0xf9. This function was initially actually implemented in nasm assembly intel x64, but at some point when trying to integrate the code into the c++ main program, debugging and troubleshooting became so much of a hassle, that I decided to simply implement it in c++. Here's the rest of the code: unsigned char original_pattern[2] = { base_vaddr[3], base_vaddr[4] }; //little endian unsigned char local_pattern[2] = { base_vaddr[3], base_vaddr[4] }; unsigned char* temp_local_pattern; LPCVOID section = libhandle+0x1000; do{ printf(\"dll current region location: %p\\n\",section); MEMORY_BASIC_INFORMATION mem_info = MEMORY_BASIC_INFORMATION{}; VirtualQuery(section, &mem_info, sizeof(mem_info)); SIZE_T size = mem_info.RegionSize; DWORD protection_state = mem_info.Protect; printf(\"analysing the protection: %p\\n\", protection_state); if(protection_state==PAGE_EXECUTE_READWRITE){ cout << \"[*******] Detected RWX\\n\"; return true; } temp_local_pattern = (unsigned char*)&section; local_pattern[0] = temp_local_pattern[3]; local_pattern[1] = temp_local_pattern[4]; section = section + mem_info.RegionSize; } while(local_pattern[0] == original_pattern[0] && local_pattern[1] == original_pattern[1]); return false; } Using this algorithm I was able to find the following libraries for mockingjay injection, two of them are actually the same library showcased in the debut article, but this time located in the installation of ruby 3.1 and 3.3, with the second one being an actual surprise, found in the bin folder of cygwin64. dlls found: - ruby 3.1 x64 : c:\\\\installlocation\\\\msys64\\\\usr\\bin\\msys-2.0.dll - ruby 3.3 x64 : C:\\Ruby33-x64\\msys64\\usr\\bin\\msys-2.0.dll - cygwin : C:\\cygwin64\\bin\\cygwin1.dll By me References: - https://www.securityjoes.com/post/process-mockingjay-echoing-rwx-in-userland-to-achieve-code-execution - https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualquery - https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants - https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/ns-memoryapi-win32_memory_region_information - https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views","title":".Companion scanner for mockingjay injection"},{"location":"dllMemoryScanner/#companion-scanner-for-mockingjay-injection","text":"The mockingjay process injection technique, despite conceptually simple is nothing to be mocked at. The authors, acknowledging the fact that EDR systems focus more on certain win32 API calls, decided to seek an alternative which was either less dependent on these API calls or reduced their usage in some way. During their analysis of the most used injection techniques, two common operations were identified as being easily flagged as malicious: memory space allocation and changing memory protections to Read-Write-Execute (RWX), performed by NtWriteVirtualMemory and NtProtectVirtualMemory. Yup these are some of the usual surveillance targets for our friendly neighbourhood crowdstrikes, err I mean EDRs. So the solution found by Thiago et al. was to identify vulnerable DLLs with default RWX memory sections and exploit the trust these libraries hold with Windows to inject and execute shellcode undetected by modern anti-virus. The original article describing the mockingjay technique is seriously interesting, I highly recommend the reader to give it a look https://www.securityjoes.com/post/process-mockingjay-echoing-rwx-in-userland-to-achieve-code-execution. Whats this article about then? well when reading the original article myself, I noticed the authors didn't provide the source code or described their approach when looking for vulnerable DLLs. I know there's code for this out there, but i thought about writing a tool without looking too much into what other people had already done, just to learn more about the subject.","title":".Companion scanner for mockingjay injection"},{"location":"dllMemoryScanner/#handlewalk-algorithm","text":"When searching for a usable dll, the process starts by recursively crawl a target base directory, further diving into other dirs and ignoring all files without the .dll extension. After finding a library file, first thing to attempt was to load it into the program, despite not being the fastest/most stable approach, it allowed me to exclude right away libraries that couldn't be used for self-injection with the mockingjay technique. The rationale here was that if you can't load it into your process, you won't be able to exploit the memory protections anyway, at least for self-injection which is my focus here. When the algorithm manages to load a DLL, then the fun begins. The returned HMODULE handle after calling LoadLibraryA on the DLL, will be the starting point of our search for a vulnerable memory section. During research I found an interesting pattern, looking at the DLL handle we can see it pointing to the base virtual address of the library after being loaded into the processe's memory. If we look at the memory map of any loaded dll, we can confirm the next section/region is always .text, and it's always at an offset of +0x1000 from the HMODULE address. So far the logic is clear, the script loads a dll, adds 0x1000 to the library handle value to get the address of the .text section and requests information about this section, then checks the memory protections and adds the size of the section to the handle, this way we get the address of the next section and repeat the process until we find a RWX section. With the inner workings figured out, I needed to find an API function which could be used to get the size and protections of a given memory section. The obvious location to find the right tool was in memoryapi.h , looking at the documentation for VirtualQuery: SIZE_T VirtualQuery( [in, optional] LPCVOID lpAddress, [out] PMEMORY_BASIC_INFORMATION lpBuffer, [in] SIZE_T dwLength ); It takes three arguments, lpAddress is a pointer to the base address of the region we want to query, lpBuffer is a pointer to a MEMORY_BASIC_INFORMATION structure which will hold the results, and dWLength is the size, in bytes, of the MEMORY_BASIC_INFORMATION buffer. Taking a better look at this struct shows: typedef struct _MEMORY_BASIC_INFORMATION { PVOID BaseAddress; PVOID AllocationBase; DWORD AllocationProtect; WORD PartitionId; SIZE_T RegionSize; DWORD State; DWORD Protect; DWORD Type; } MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION; We can see it has the RegionSize and Protect, which will give us the size of the region in bytes and the memory protections applied to said region. Something worthy of note, which I didn't initially realised, was that the MEMORY_BASIC_INFORMATION structure returned by the VirtualQuery call, refers to a memory region, not a memory section. During development this led to one of those situations where some debugging sessions could have been avoided by more carefully reading the documentation haha. If we look at the header sections of the cygwin1.dll in PE-Bear, we can identify a certain layout: We got the .text section, and then the /4 section with a mapped virtual size of 4000 bytes. This can also be confirmed using x64dbg: But these are memory sections, what about regions? Changing the layout to display memory by regions, we can tell its slightly different: VirtualQuery would always return two different regions of 3000 and 1000 bytes after .text, instead of a single region of 4000 bytes. So my dumb self would initially get cross-eyed looking at this until I realised what the API call was returning. According to ms: \"A memory region is a single allocation that is created using a memory allocation function, such as VirtualAlloc or MapViewOfFile.\" There is also a remark on https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/ns-memoryapi-win32_memory_region_information, regarding the MEMORY_BASIC_INFORMATION structure and how it describes a \"contiguous run of pages within a single allocation that all have the same type, state and protection.\" While a section is mainly defined as: \"A section object represents a section of memory that can be shared. A process can use a section object to share parts of its memory address space (memory sections) with other processes. Section objects also provide the mechanism by which a process can map a file into its memory address space.\" What's happening here is that when a program loads a DLL, the OS first reads and maps the file's sections into the virtual memory space of the loader, and then allocates regions according to each section characteristics. This is actually observable in the last picture, the first 1000 bytes of the /4 region have ERW protections, while the last 3000 are ERWC. And that's it, to search for loadable DLLs with RWX regions the algorithm goes something like this: - Recursively search directories for .dll files. - Try to load the DLL using 'LoadLibraryA'. - If loaded, add 0x1000 to the handle's value. - VirtualQuery on the .text region. - Check memory protections and add the size of the current region to the get the next. - Repeat last instruction until the end of the DLL's virtual memory space. The code itself is nothing special, all written in c++, the directory crawling part was implemented using the FindFirstFile winapi function, with the interesting bit being the find_mockingjay function: bool find_mockingjay(HMODULE libhandle){ unsigned char* base_vaddr = (unsigned char*) &libhandle; First thing I did was to cast the HMODULE to an unsigned char* . This made arithmetics easier, allowing me to jump between memory regions by adding the size of the current region to the virtual address of the previous. Termination criteria was also something fun to write. The how is actually interesting, I noticed that the least significant byte of the upper 32 bits of the handle address value and the most significant byte of the lower 32 bits, were different for each library loaded dynamically and from the native DLLs loaded when the program started. So when eventually these specific bytes are different from the ones extracted from the original handle, you've stepped into a different memory region unrelated to the library being analysed. So for a handle with a value of 0x00007ff90e7a0000, the crawling termination bytes would be 0x0e and 0xf9. This function was initially actually implemented in nasm assembly intel x64, but at some point when trying to integrate the code into the c++ main program, debugging and troubleshooting became so much of a hassle, that I decided to simply implement it in c++. Here's the rest of the code: unsigned char original_pattern[2] = { base_vaddr[3], base_vaddr[4] }; //little endian unsigned char local_pattern[2] = { base_vaddr[3], base_vaddr[4] }; unsigned char* temp_local_pattern; LPCVOID section = libhandle+0x1000; do{ printf(\"dll current region location: %p\\n\",section); MEMORY_BASIC_INFORMATION mem_info = MEMORY_BASIC_INFORMATION{}; VirtualQuery(section, &mem_info, sizeof(mem_info)); SIZE_T size = mem_info.RegionSize; DWORD protection_state = mem_info.Protect; printf(\"analysing the protection: %p\\n\", protection_state); if(protection_state==PAGE_EXECUTE_READWRITE){ cout << \"[*******] Detected RWX\\n\"; return true; } temp_local_pattern = (unsigned char*)&section; local_pattern[0] = temp_local_pattern[3]; local_pattern[1] = temp_local_pattern[4]; section = section + mem_info.RegionSize; } while(local_pattern[0] == original_pattern[0] && local_pattern[1] == original_pattern[1]); return false; } Using this algorithm I was able to find the following libraries for mockingjay injection, two of them are actually the same library showcased in the debut article, but this time located in the installation of ruby 3.1 and 3.3, with the second one being an actual surprise, found in the bin folder of cygwin64. dlls found: - ruby 3.1 x64 : c:\\\\installlocation\\\\msys64\\\\usr\\bin\\msys-2.0.dll - ruby 3.3 x64 : C:\\Ruby33-x64\\msys64\\usr\\bin\\msys-2.0.dll - cygwin : C:\\cygwin64\\bin\\cygwin1.dll By me References: - https://www.securityjoes.com/post/process-mockingjay-echoing-rwx-in-userland-to-achieve-code-execution - https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualquery - https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants - https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/ns-memoryapi-win32_memory_region_information - https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views","title":"Handlewalk algorithm"}]}